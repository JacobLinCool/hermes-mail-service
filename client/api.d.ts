/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/api/auth": {
		post: {
			requestBody?: {
				content: {
					"application/json": {
						/** @description The main key */
						mainkey: string;
					};
					"application/x-www-form-urlencoded": {
						/** @description The main key */
						mainkey: string;
					};
					"multipart/form-data": {
						/** @description The main key */
						mainkey: string;
					};
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description Indicates if the main key is correct */
							ok: boolean;
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
			};
		};
	};
	"/api/config": {
		get: {
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description A map of configuration keys to their values */
							config: {
								[key: string]: string | null;
							};
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Unauthorized */
				401: {
					content: never;
				};
			};
		};
	};
	"/api/config/{key}": {
		get: {
			parameters: {
				path: {
					/** @description The configuration key to set */
					key: "cors" | "save-raw";
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description The value of the configuration key */
							value: string | null;
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Unauthorized */
				401: {
					content: never;
				};
			};
		};
		put: {
			parameters: {
				path: {
					/** @description The configuration key to set */
					key: "cors" | "save-raw";
				};
			};
			requestBody?: {
				content: {
					"application/json": {
						/** @description The new value to set for the configuration key */
						value: string;
					};
					"application/x-www-form-urlencoded": {
						/** @description The new value to set for the configuration key */
						value: string;
					};
					"multipart/form-data": {
						/** @description The new value to set for the configuration key */
						value: string;
					};
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description A message indicating the success of the operation */
							message: string;
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Unauthorized */
				401: {
					content: never;
				};
			};
		};
	};
	"/api/config/mainkey": {
		put: {
			requestBody?: {
				content: {
					"application/json": {
						/** @description The new main key to use for the service */
						mainkey: string;
					};
					"application/x-www-form-urlencoded": {
						/** @description The new main key to use for the service */
						mainkey: string;
					};
					"multipart/form-data": {
						/** @description The new main key to use for the service */
						mainkey: string;
					};
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description A message indicating the success of the operation */
							message: string;
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Previous main key does not match */
				401: {
					content: never;
				};
			};
		};
	};
	"/api/healthcheck": {
		get: {
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description A message indicating the health of the service, always 'OK' */
							message: string;
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Service unavailable, some configuration is missing */
				503: {
					content: never;
				};
			};
		};
	};
	"/api/send": {
		post: {
			requestBody?: {
				content: {
					"application/json": {
						from:
							| {
									/** Format: email */
									email: string;
									name?: string;
							  }
							| string;
						personalizations: {
							to: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							from?:
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string;
							bcc?: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							cc?: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							/**
							 * @description A JSON object containing key/value pairs of header names and the value to substitute for them.
							 * The Key/value pairs must be strings. You must ensure these are properly encoded if they
							 * contain unicode characters. Must not be one of the reserved headers (received, dkim-signature,
							 * Content-Type, Content-Transfer-Encoding, To, From, Subject, Reply-To, CC, BCC).
							 */
							headers?: {
								[key: string]: string;
							};
							reply_to?:
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string;
							subject?: string;
						}[];
						subject: string;
						content: {
							/**
							 * @description The mime type of the content you are including in your email
							 * @enum {string}
							 */
							type: "text/plain" | "text/html";
							/** @description The actual content of the specified mime type that you are including in the message */
							value: string;
						}[];
						/**
						 * @description A JSON object containing key/value pairs of header names and the value to substitute for them.
						 * The Key/value pairs must be strings. You must ensure these are properly encoded if they
						 * contain unicode characters. Must not be one of the reserved headers (received, dkim-signature,
						 * Content-Type, Content-Transfer-Encoding, To, From, Subject, Reply-To, CC, BCC).
						 */
						headers?: {
							[key: string]: string;
						};
						reply_to?:
							| {
									/** Format: email */
									email: string;
									name?: string;
							  }
							| string;
					};
					"application/x-www-form-urlencoded": {
						from:
							| {
									/** Format: email */
									email: string;
									name?: string;
							  }
							| string;
						personalizations: {
							to: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							from?:
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string;
							bcc?: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							cc?: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							/**
							 * @description A JSON object containing key/value pairs of header names and the value to substitute for them.
							 * The Key/value pairs must be strings. You must ensure these are properly encoded if they
							 * contain unicode characters. Must not be one of the reserved headers (received, dkim-signature,
							 * Content-Type, Content-Transfer-Encoding, To, From, Subject, Reply-To, CC, BCC).
							 */
							headers?: {
								[key: string]: string;
							};
							reply_to?:
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string;
							subject?: string;
						}[];
						subject: string;
						content: {
							/**
							 * @description The mime type of the content you are including in your email
							 * @enum {string}
							 */
							type: "text/plain" | "text/html";
							/** @description The actual content of the specified mime type that you are including in the message */
							value: string;
						}[];
						/**
						 * @description A JSON object containing key/value pairs of header names and the value to substitute for them.
						 * The Key/value pairs must be strings. You must ensure these are properly encoded if they
						 * contain unicode characters. Must not be one of the reserved headers (received, dkim-signature,
						 * Content-Type, Content-Transfer-Encoding, To, From, Subject, Reply-To, CC, BCC).
						 */
						headers?: {
							[key: string]: string;
						};
						reply_to?:
							| {
									/** Format: email */
									email: string;
									name?: string;
							  }
							| string;
					};
					"multipart/form-data": {
						from:
							| {
									/** Format: email */
									email: string;
									name?: string;
							  }
							| string;
						personalizations: {
							to: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							from?:
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string;
							bcc?: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							cc?: (
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string
							)[];
							/**
							 * @description A JSON object containing key/value pairs of header names and the value to substitute for them.
							 * The Key/value pairs must be strings. You must ensure these are properly encoded if they
							 * contain unicode characters. Must not be one of the reserved headers (received, dkim-signature,
							 * Content-Type, Content-Transfer-Encoding, To, From, Subject, Reply-To, CC, BCC).
							 */
							headers?: {
								[key: string]: string;
							};
							reply_to?:
								| {
										/** Format: email */
										email: string;
										name?: string;
								  }
								| string;
							subject?: string;
						}[];
						subject: string;
						content: {
							/**
							 * @description The mime type of the content you are including in your email
							 * @enum {string}
							 */
							type: "text/plain" | "text/html";
							/** @description The actual content of the specified mime type that you are including in the message */
							value: string;
						}[];
						/**
						 * @description A JSON object containing key/value pairs of header names and the value to substitute for them.
						 * The Key/value pairs must be strings. You must ensure these are properly encoded if they
						 * contain unicode characters. Must not be one of the reserved headers (received, dkim-signature,
						 * Content-Type, Content-Transfer-Encoding, To, From, Subject, Reply-To, CC, BCC).
						 */
						headers?: {
							[key: string]: string;
						};
						reply_to?:
							| {
									/** Format: email */
									email: string;
									name?: string;
							  }
							| string;
					};
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							ok: boolean;
							error?: string;
						};
					};
				};
				/** @description Bad Request */
				400: {
					content: never;
				};
				/** @description Invalid Token */
				401: {
					content: never;
				};
				/** @description Sender Address / Domain Not Permitted */
				403: {
					content: never;
				};
			};
		};
	};
	"/api/token": {
		get: {
			parameters: {
				query?: {
					/** @description The number of tokens to skip */
					offset?: number;
					/** @description The number of tokens to take */
					limit?: number;
					/** @description The order to sort the tokens */
					order?: "asc" | "desc";
					/** @description The field to sort the tokens by */
					sort?: "scope" | "created" | "expires";
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description The tokens */
							tokens: {
								/** @description The token ID */
								id: string;
								/** @description The token scope */
								scope: string;
								/** @description The token creation date */
								created: number;
								/** @description The token expiration date */
								expires: number;
								/** @description The token revocation date */
								revoked: number | null;
							}[];
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Unauthorized */
				401: {
					content: never;
				};
				/** @description Token not found */
				404: {
					content: never;
				};
			};
		};
		post: {
			requestBody?: {
				content: {
					"application/json": {
						/** @description The token scope */
						scope: string;
						/** @description The token expiration date */
						expires: number;
					};
					"application/x-www-form-urlencoded": {
						/** @description The token scope */
						scope: string;
						/** @description The token expiration date */
						expires: number;
					};
					"multipart/form-data": {
						/** @description The token scope */
						scope: string;
						/** @description The token expiration date */
						expires: number;
					};
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description The token ID */
							id: string;
							/** @description The token scope */
							scope: string;
							/** @description The token creation date */
							created: number;
							/** @description The token expiration date */
							expires: number;
							/** @description The token revocation date */
							revoked: number | null;
						};
					};
				};
				/** @description Bad Request */
				400: {
					content: never;
				};
				/** @description Unauthorized */
				401: {
					content: never;
				};
			};
		};
	};
	"/api/token/{id}": {
		get: {
			parameters: {
				path: {
					/** @description The token to check */
					id: string;
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description The token ID */
							id: string;
							/** @description The token scope */
							scope: string;
							/** @description The token creation date */
							created: number;
							/** @description The token expiration date */
							expires: number;
							/** @description The token revocation date */
							revoked: number | null;
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Token not found */
				404: {
					content: never;
				};
			};
		};
		delete: {
			parameters: {
				path: {
					/** @description The token to check */
					id: string;
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							/** @description Whether the token was deleted */
							ok: boolean;
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Unauthorized */
				401: {
					content: never;
				};
				/** @description Token not found */
				404: {
					content: never;
				};
			};
		};
	};
	"/api/token/{id}/records": {
		get: {
			parameters: {
				path: {
					/** @description The token to check */
					id: string;
				};
			};
			responses: {
				200: {
					content: {
						"application/json": {
							records: {
								/** @description The token ID */
								token: string;
								/** @description The timestamp of the record */
								timestamp: number;
								/** @description The source of the record */
								from: string;
								/** @description The destination of the record */
								to: string;
								/** @description The subject of the record */
								subject: string;
								/** @description The raw data of the send request */
								raw: string | null;
							}[];
						};
					};
				};
				/** @description Invalid input (path parameters, query string, or body) */
				400: {
					content: {
						"application/json": {
							message: string;
						};
					};
				};
				/** @description Token not found */
				404: {
					content: never;
				};
			};
		};
	};
}

export type webhooks = Record<string, never>;

export interface components {
	schemas: {};
	responses: never;
	parameters: {};
	requestBodies: never;
	headers: never;
	pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export type operations = Record<string, never>;
